# 抽象的代价

经常讨论和编写重复代码，积累技术债务，不进行测试等方面的成本.

抽象事物尽管是任何项目可维护的主要因素, 但抽象成本却很少被提到.

一个简单的例子, 两个变量指定顺序的自增.
```
i++;
j++;
```

所以认为这个功能值得变为一个专门的方法.
```
template<typename T> inc_pair(T &i, T &j) {
    i++;
    j++;
}
```

你删除了写重复代码, 但是你引入了新的抽象`inc_pair`, 这是很少被提及的.

这个特殊情况, 几乎所有人都同意添加这个抽象是不值得的. 为什么呢? 在复制代码和抽象之间的权衡. 但是, 为什么某类复制代码的成本要比"抽象的成本"低呢?

为了回答这个问题, 我们来看看"抽象成本"真正的含义.

抽象一个明显的代价, 会使任何理解代码的人的认知成本增加. 他必须记住一个事实, `inc_pair`是将两个参数加一的函数.

但是, 抽象的主要成本是实现和规范分开, 或换一种方法, 将函数的字母和函数和意思分开. 前者是功能要做的作用, 后者是每个人都要做的事情.

上一句中重要的是"每一个人", 你进行了一次抽象, 它不再是你相信它在做什么. 你正在进入社会公共领域. 这是每个人都认为的事情. 每个人都知道, 社会共识是困难的.

让我们看看这个实际的例子, 如果`inc_pair`的类型`T`是`Duration`类型? 方法将做什么? 时间将加上一秒? 一天? 一纳秒? 可能没有统一的答案

另一个例子: 如果在类型`T`执行`++`操作, 在执行`j++`发生了异常将怎样处理. 函数会使i和j处于不一致状态吗? 还是通过`i-`操作保持原子性? `i-`发生异常将怎样处理? 或许函数应该先复制旧变量的值, 在发生错误的时候在重新设置回去? 没有人知道.

很多项目已经过度抽象, 以至于无法维护. 因此, 程序员习惯了不可维护的状态，将其视为正常的事务状态, 并且他们通过添加越来越多的抽象来为混乱带来快乐.

我已经展示了一个没有特别好的理由就添加新抽象的示例, 程序员注意到, 将两段相似的代码合并为一个方法. 这样做的成本很少被注意到.

另一个示例, 在测试中使用模拟, 尽管测试绝对有用. 通常需要对某些代码进行抽象以便可以对其进行测试. 例如, 通过创建接口, 然后同时具有接口的实际和模拟实现. 而这种创建额外的抽象只有损害的.

有一个例子, 创建继承层级. 我们想要四个类: `产卵的鱼`,`活鱼`,`产卵的哺乳动物`和`活的哺乳动物`. 直观反映创建顶层类`Animal`, 创建子层级`Fish`和`Mammal`. 即使没有和这些类一起工作的用例. 然后未来的维护者必须为这些抽象类抓狂.

最后来看看对抗抽象的一些工具.

首先: 我们有范围限制. 在c语言中, 方法被修饰为`static`只能在本文件中可见. 这限制了可能造成的损害, 它依然hi一个IE抽象, 但可以方式泄漏给更多读者. 类似的java有`private`. 当然, 这不是万能药, 在源码超过10000行的, 静态功能将大大扩展, 并且与非静态一样危险.

我们有匿名对象(lambdas表达式).事实证明, 将没有名字的东西当作抽象是很难的. 如果引用函数的唯一方法是将其写下来,那么函数的意思就会更加复杂.

想go的隐是接口来避免不必要的抽象. 假设在实现对象时未定义接口, 而是可以根据用户的需要即时创建接口, 则接口的范围可能会受到很大限制, 从而使受抽象影响的人数减少

最后的问题, 我们做足够的事情来限制我们的抽象的数量. 我们是否有足够的工具去做. 尽管在很多情况下, 这似乎是程序员的态度问题, 但至少在进行模拟的情况下, 工具本身才是导致问题的原因.

# 个人理解

正片我理解, 的抽象是针对公共方法, 接口, 父类的抽象

不要过度抽象, 在spring框架的一个狗血范式就是所有service都要有interface. 但是这个interface只有一个实现类, 而这种实际上没有实际的意义. 当有多个实现类的时候在进行抽象也是值得的.

践行单一职责和减少可见性是好的方案, 但总比没有抽象要好. 在现在接收的烂代码有一个特殊的抽象, 完全无法理解这层抽象的意义是啥. 通过所有行为可以判断最开始想用模板模式, 但一步一步把抽象类变成了工具类, 抽象的意义完全丢失了.

这是一个度的把握, 过多不好, 过少也不好. 我理解可以用一下原则做个参考:

* 单一职责
* 不要扩大使用范围, 在本文件内使用
* 如果想不到一个好名字就不要发布出去
* 多考虑组合少用继承
* 不要过早抽象
* 记录详细的开发日志, 抽象的原因比代码重要


原文: [The Cost of Abstraction](http://250bpm.com/blog:86)
