# 解读NoSQL

> [美]丹·麦克雷 安·凯利 (作者), 范东来 滕雨橦 (译者)

> (2019/02/07-2019/03/01)

1. NoSQL是关于快速而高效地处理数据, 专注于性能, 可靠性和敏捷性的一组概念. 
2. 那么NoSQL究竟是什么?  NoSQL 不仅仅是普通意义上的表——NoSQL系统可以从许多格式中存储和检索数据: 键值存储, 图数据库, 列族存储, 文档存储甚至是普通的表.  NoSQL避免连接操作——NoSQL系统能够通过简单的接口提取数据从而避免连接操作.  NoSQL 是模式无关的——NoSQL系统允许将数据拖曳到一个文件夹并进行查询, 而不需要创建对象-关系模型.  NoSQL 工作在多核处理器之上——NoSQL系统允许将数据库部署在多核处理器之上从而保持良好的性能.  NoSQL 运行在无共享的商用计算机——大多数(并不是所有的)NoSQL系统利用廉价的商用处理器, 独立的硬盘和内存进行搭建.  NoSQL 支持线性扩展——当你增加更多的处理器时, 你的单位性能增量始终是一致的.  NoSQL 是创新的——NoSQL对于存储, 检索, 操作数据提供了更多的选择. NoSQL的支持者(也被称为NoSQLers)对于NoSQL和SQL解决方案持一种兼收并蓄的态度. 对于NoSQL社区来说, NoSQL的意思是"不只是SQL". 
3. 同样重要的是, NoSQL不是什么.  NoSQL 不是一种SQL语言——NoSQL并不是采用非SQL查询语言的应用. SQL和其他查询语言也可以被用于NoSQL数据库.  NoSQL 不仅是开源的——尽管许多NoSQL系统都有一个开源模式, 但是借鉴NoSQL思想的商业产品同样也不排斥开源. 你仍然可以通过商业产品创新地解决问题.  NoSQL 不仅仅代表海量数据——大部分但不是所有的NoSQL应用都是来源于为应对海量数据而提升当前应用运行规模的需求. 虽然数据的容量和数据处理速度很重要, 但NoSQL 也专注于数据的种类和敏捷性.  NoSQL 和云计算没有关系——虽然很多NoSQL系统为了能在负载变化时利用云端动态扩展的优势而部署在云端, 但是NoSQL系统也能像在云端运行那样运行在公司的数据中心.  这不是关于如何用好RAM和SSD——NoSQL专注于高效地使用RAM和固态硬盘获得性能的提升, 尽管这很重要, 但是NoSQL系统可以运行在普通硬件之上.  NoSQL 并不是精英团体的专属产品——NoSQL不是一个排他的, 只有少数产品的俱乐部, 也并没有为加入设置门槛. 想成为一个NoSQLer, 你只需说服别人, 对于他们的业务难题你有创新的解决思路. 
4. RDBMS的优势如下.  数据库级别的事务ACID特性让开发变得容易.  使用视图的基于行列细粒度的安全性阻止了未授权用户查看和修改.  大多数SQL代码都可以移植到其他SQL数据库, 包括一些开源产品.  预先定义的数据类型和约束条件在数据库加载数据之前将验证数据的有效性, 从而提升数据的质量.  用户已经对SQL和实体-关系的设计思想非常熟悉.  RDBMS的劣势如下.  对象-关系映射层很复杂.  实体-关系模型必须在测试之前建立, 这会拖慢开发速度.  RDBMS对于连接操作不能动态扩展.  可以将数据分片至多个服务器, 但是需要进行应用级别的开发并且效率低下.  全文搜索需要第三方工具.  将高度灵活的数据保存到结构化的表中非常困难.  NoSQL的优势如下.  在ER模型完成之前就可以用拖曳工具加载测试数据.  模块化的架构使组件之间可以交换.  可通过在集群中增加新处理节点来进行线性扩展.  通过自动分片可降低开销成本.  整合的搜索函数提供了高质量的排名搜索结果.  不需要对象-关系映射层.  存储变化性强的数据非常简单.  NoSQL的劣势如下.  在数据库级别, ACID事务只能在一个文档内完成, 其他事务必须在应用层完成.  文档存储在元素级别不提供细粒度的安全性.  NoSQL系统对于很多员工来说是全新的, 需要额外的培训.  文档存储有自己独有的非标准查询语言, 这妨碍了可移植性.  文档存储不能与现有的报表和OLAP工具一起工作. 
5. RDBMS的事务控制通过原子性, 一致性, 隔离性和持久性(ACID)属性来保证事务是可靠的. 
6. ACID系统可以说是悲观的, 因为它们必须考虑计算环境里所有可能的失效模式. 
7. BASE的一些概念.  基本可用是指允许系统暂时不一致, 这样事务就容易管理. 在BASE系统中, 信息和服务能力是"基本可用的".  软状态是指为了降低消耗的资源, 可以暂时允许一些不准确的地方和数据的变换.  最终一致性意味着在最后, 当所有服务逻辑执行完成后, 系统最后将回到一个一致的状态. 
8. 与RDBMS关注一致性不同, BASE系统关注可用性. BASE系统显著的特点是它们的首要目标是要保证在短时间内, 即使有不同步的风险, 也要允许新数据能够被存储. 
9. 数据库的成长性和自动分区数据的容错性对于NoSQL系统来说很重要. 对于大数据系统和容错系统, 分片操作已经成为高度自动化的过程. 
10. CAP定理只适用于集群中出现连接故障的某些情况. 网络越可靠, 需要考虑CAP定理的可能性就越低. 
11. 你如果已经对联机事务处理(OLTP), 联机分析处理(OLAP)和用于分布式修改控制系统的概念有所了解, 
12. 没有什么模式是孤立的实体. 每个模式能够存在于世界上, 在某种程度上, 仅仅是由于它被其他模式所支持: 它所嵌入的更大的模式, 被同等规模的模式包围, 并且还有更小的模式嵌入其中. 
13. 使用文档存储的结果是当添加新文档时, 文档中的一切事物都会被自动建好索引. 
14. CouchDB使用MVCC来保证面向文档的ACID事务, 并且也支持文档版本控制. 
15. 对于海量数据的快速分析是各个公司, 组织放弃传统的单处理器关系型数据库管理系统(RDBMS), 转而投入 NoSQL 解决方案的首要原因. 也许你还能回想起我们在第1章中讨论的4个
16. 分布式模型揭示一个核心问题: 由谁管理集群. 可选答案有两个: 一个节点或者所有节点. 
17. 采用何种合适的分布式模型取决于业务需求: 如果高可用性非常重要, 对等网络的解决方案可能更好;如果只需要运行数小时的批处理任务来管理大数据, 相对来说更简单的主从模型可能更好. 
19. 的. 下面是一些可以加入系统中的搜索类型.  全文搜索——全文搜索是指查找包含类似英语的自然语言的文档. 全文搜索适用于查找没有特定结构的数据, 如一篇文章或一本书. 全文搜索技术中也包括了剔除不重要的虚词("和""或""这"等)以及删除单词后缀等处理技术.  半结构化搜索——半结构化搜索是指针对同时包含关系型数据库那样严格的结构形式和像Office文档里那样的全文句子的数据查找. 例如, 一张数小时咨询项目有关的发票上可能包含了一大段描述项目任务的句子. 一个销售订单中可能包含了产品的文本描述. 一个商业需求文档也许既包含了像谁提出了新功能, 哪个发布版本将包含这个功能这样的结构化字段又包括了一段功能细节描述的文本信息.  基于地域的搜索——基于地域的搜索是指根据地理位置距离的远近排序并返回搜索结果的查找过程. 例如, 查找距离你5分钟车程的所有寿司店地址. 像Apache Lucene这样的搜索框架现在已经集成了可以综合位置信息对搜索结果排序的工具.  网络搜索——网络搜索是指根据在类似社交网络的图中获取到的信息排序并返回结果的搜索过程. 例如, 你可能只想搜索朋友给过 4 星或 5 星评价的餐馆. 集成网络搜索结果需要使用社交网络开放的API来引入类似"我Facebook好友的平均打分"这样的搜索条件.  分面搜索——分面搜索是指查找条件中包含其他文档属性的搜索, 如"查找某个作者在某个时点之前完成的所有文档". 你可以把"分面"认为是用来缩小搜索范围的分类. 但是它也可以用来重排序搜索结果.  你可以通过在每个文档上手工添加多个关键字标签的方式为普通Word文档设置分面搜索, 但是添加关键字带来的成本增加可能高于其收益. 分面搜索适用于每个文档都有高质量元数据(文档属性信息)的搜索场景. 例如, 多数图书馆都会购买中央数据库中的书籍元数据以便于根据内容主体, 作者, 发行日期和其他一些标准化属性缩小搜索范围. 这些属性有时也被称为文档的都柏林核心(Dublin core)属性.  向量搜索——向量搜索是指用多维向量距离模型计算出数据与搜索关键字的距离并据此排序并返回搜索结果的查找过程. 如果把每个关键字都看做空间中的一个维度, 那么一个查询和每个文档间的距离就可以像计算地理距离一样被计算出来, 如图7-1所示.  图7-1　向量搜索是查找距离搜索关键字最近的文档的一种方法. 通过计算每页中某个关键字的数目, 可以对所有文档按一个关键字维度排序 正如你所猜测的那样, 计算搜索向量非常复杂. 但幸运的是, 多数全文搜索框架都已实现了该算法. 一旦建好全文索引, 搜索引擎的构建就会像在搜索框中输入查询语句一样简单. 向量搜索是允许用户使用模糊查询功能的一项关键技术. 该技术可以找到不完全匹配查询条件但"临近查询关键字"的文档. 向量搜索工具也支持将整个文档作为一个关键词集合来实现一些特别的搜索. 该特性使得搜索系统可以提供类似"查找与某个文档相似文档"的功能.  N-gram搜索——N-gram搜索是指在搜索可能包含空白字符的内容时, 先将需要搜索的内容中的长字符串分割成数个较短的定长字符串(通常是3个字符)并对这些分割后的字符串建立索引, 再在这些索引上执行完全匹配搜索的查找过程. N-gram索引会占用大量磁盘空间, 但它是快速搜索像软件源代码这种(包含空白符在内的所有字符都很重要的)文本数据的唯一方法. N-gram索引也可用来搜寻存在于类似DNA序列的长字符串中的潜在模式.  虽然存在着许多种搜索类型, 但也有很多工具可以帮助我们使这些搜索快速高效地执行. 随着下一节的讨论, 你将看到NoSQL系统快速查找并获取到期望信息的能力. 
20. 让我们来看看使NoSQL系统能高效搜索的策略和方法.  范围索引——范围索引是指用升序的方式为数据库中的所有记录创建索引的方式. 范围索引非常适合条件是字母序关键字, 日期, 时间戳, 等于或处于特定值之间的数量等的搜索. 范围索引可以用来为任何能够按照某种逻辑顺序排序的数据类型创建索引, 而为图片或全文本段落创建范围索引则不那么明智.  倒排索引——倒排索引和书籍后面的索引比较类似. 在一本书中, 每个引用及其出现的页码都会按字母顺序被列在书的最后. 可以根据索引中的条目在书中快速找到使用术语的地方. 如果没有这些索引, 你将不得不通过扫描整本书的方式进行查找. 搜索软件也是使用相同的方式来利用倒排索引——针对一堆文本文档中的每个词都有一个包含了所有出现过这个词的文档列表. 图7-2是一张莎士比亚戏剧的Lucene索引的截图.  图7-2　从一份莎士比亚戏剧的倒排索引中检索以"love"开头的词. 在这个例子中, 系统会将剧本以TEL XML格式编码, 并用Apache Lucene为其建立索引 类似Apache Lucene的搜索框架的设计初衷之一就是能够用来创建并管理海量文本的倒排索引. 这些倒排索引能够加速文档中的关键字搜索.  搜索排序——搜索排序是指根据用户期望结果相似度排序搜索结果的过程. 如果一个文本中某个关键词密度越高, 那么这个文本的内容越可能和这个关键词有关. 术语"关键词密度"(keyword density)是指一个关键字在一个根据文本大小加权后的文档中出现的次数. 如果只是单纯地计算一个文本中词的出现次数, 那么内容越多关键词越多的文本总会拥有更高的排序. 搜索排序要同时考虑文本中关键词出现次数和文本总词数两个方面, 以此避免长文本一直处于搜索结果中前几位的可能. 排序算法也考虑诸如文档类型, 社交网络中的推荐, 与某个特定任务的关联度等其他因素.  提取词干——提取词干是指在搜索中将用户以多种形式提供的词干和该词的其他形式相匹配的过程. 例如, 如果一个人输入一个关键词"walk", 那么包含walks, walked和walking的文本也可能被包含在搜索结果中.  同义词扩展——同义词扩展是指在搜索结果中引入包含搜索关键字同义词的文本的过程. 例如, 如果用户输入"阿司匹林"作为关键字, 那么它的化学名称水杨酸, 乙酰水杨酸也可能会被作为关键词进行搜索. WordNet数据库就是一个利用词库在搜索结果中包含同义词的好例子.  实体提取——实体提取是指查找文本中出现的实体并对其打上标签的过程. 诸如日期, 人名, 组织, 地理位置和产品名称等类型的对象都应该被实体提取程序打上标签. 最常见的标记文本的方法是使用XML包装元素. 像MarkLogic这样的纯XML数据库就提供了在文本中自动查找实体并打上标签的功能.  通配符搜索——通配符搜索是指通过添加特殊的字符来表明希望查询语句能够匹配上多种字符的过程. 多数搜索框架支持后缀通配符. 例如, 用户输入"dog\*", 搜索程序将会匹配"dog", "dogs", "dogged". 可以使用"\*"来匹配0个或多个的字符, 而"?"则是匹配单一字符. Apache Lucene允许在字符串中间使用通配符.  多数搜索引擎不支持前导通配符或在一个字符前添加通配符. 例如, "\*ing"这样的用法是期望匹配所有以"ing"结尾的词. 因为这种类型的搜索的需求并不强烈, 而支持这种功能会使现有索引的体积加倍, 所以多数搜索引擎不支持这种通配符用法.  邻近搜索——邻近搜索是指搜索与文档中某些词距离相近的词. 例如, 可以查找所有包含"dog"和"love"且这两个词之间不超过20个词的文档. 文档中这两个词的距离越近, 它在返回的结果中的排序也就越靠前.  上下文关键字(KWIC)——上下文关键字库是一种在搜索结果中高亮关键字的工具. 一般是通过在搜索结果页面中出现搜索关键字的文档段落上添加一个元素装饰器的方式起到高亮的效果.  错别字联想——如果用户在搜索框中输入了一个错别字并且这个字在字典中不存在, 那么搜索引擎可能会以"你是不是想搜索......"的方式为用户提供一个替代关键字. 这个功能要求搜索引擎能够找到和某个错别字相似的字. 
21. 变更不再只是增量的. 带来不同规则的激进"非线性变更"正变得越来越频繁. 
22. 你所在的组织考验快速适应业务前提的更改吗? 你的计算机系统可以迅速响应增长的工作负载吗? 你的开发人员能够快速地为应用添加新功能以抓住新的商业机遇吗? 非编程人员可以在没有软件开发人员帮助的情况下管理业务规则吗? 你是否想过构建一个处理复杂数据的网页应用, 但没有聘用数据库建模师, SQL开发人员, 数据库管理员以及Java开发人员预算? 
23. 详细地说, 敏捷性是快速实现以下目标的能力.  构建新应用.  扩展应用快速满足新阶段的需求.  在不重写代码的前提下变更已有应用.  允许非编程人员创建和管理业务逻辑. 
24. 你可能听过这样一句话: "聪明的人解决问题, 智慧的人规避问题". 采用文档存储来规避对象关系映射层的创建的组织确实称得上有智慧. 对象层次结构向表结构的转化或相反过程可能会是应用构建过程中最令人烦恼的问题之一. 规避了对象关系层映射是NoSQL系统可以提升开发人员生产力的最主要原因. 
25. 开发. "我们冲着可扩展性而来——我们为了敏捷性而留下"这句话就是这个过程的最好总结. 
26. 世界是并发的. 世上的所有事物都不共享数据. 所有事物均通过消息沟通. 任何事物都会失效. 
27. 指令式编程就是管理程序状态 在过去40年中, 计算机系统使用的编程模式大多以状态管理为中心, 或被称为指令式编程系统(imperative programming system). 面向过程和面向对象语言都是指令式编程系统的例子. 
28. 但是最初的对象模型用来守护对象状态的方法里并没有管理并发的逻辑. 也就是说, 对象它们本身并没有考虑可能有上百个并发线程同时更新它们状态的情况. 一旦涉及回滚一系列中途失败事务中的更新操作时, 这个简单的对象模型就将变得复杂了. 因为在一个指令式的世界里追踪多个对象的状态可能是非常复杂的. 
29. 这种可以重复执行多次且不改变数据的转化被称为幂等转化(indempotent transform)或幂等事务. 幂等转化指在首次运行时会以固定方式改变环境状态但重复运行这一转化并不会损坏数据的转化过程. 例如, 如果你有一个会向XML文件添加缺失元素的过滤器, 那么这个过滤器就应该在添加元素之前确保它们在XML文件中并不存在. 
30. 这个过程被称为黄金线程模式. 
31. 函数式程序员将世界视为数据从原始形式到其他有用形式的一系列转化过程, 而非捕捉数据状态. 
32. 指令式编程有一个比较一致的问题解决(或思维)风格, 那就是需要开发人员观察周围的世界并记录其状态. 一旦这个世界的初始状态被准确地捕捉并存储到内存或对象状态中, 开发人员就会开始编写经过精心设计的方法来更新交互对象的状态. 
33. 在指令式世界里, 进程间共享数据会涉及多进程读取和写入共享内存和并配置被称为锁的内存地址来确定谁拥有修改内存的排他性权利. 这种关于谁可以读写共享内存值的复杂问题被称为并发问题. 下面是试图共享内存时会产生的问题.  程序在使用一个资源前可能对它加锁失败.  程序可能会对一个资源加锁, 但忘了解锁, 这样就会阻止其他线程使用这个资源.  程序可能会长时间锁住一个资源并阻止其他程序长期使用它.  当两个或两个以上的线程为了等待其他资源解锁而永久阻塞时, 死锁现象就会发生. 
34. 架构权衡分析步骤 现在, 你已经组建好了一个客观且代表了多方利益相关者观点的架构选型团队, 那么你也就为一个正式的架构权衡过程做好了准备. 下面列出了这个流程中涉及的典型步骤.  介绍流程——作为开始, 为每个团队成员解释清楚架构权衡流程和团队使用这个流程的原因是很重要的. 从这个阶段开始, 团队应该就团队成员组成, 决策制定流程以及过程产出达成一致. 这个团队应该了解到这个方法已经久经考验并且有着可查询的正确成功案例.  收集需求——接下来, 在可操作的情况下收集尽可能多的需求, 并将它们存放在一个可以搜索和生成报表的中央化存储结构中. 需求数据是典型的半结构化数据. 因为它们包含了结构化的数据项和描述性文本两种数据. 那些不用数据库存储需求的组织通常将他们的需求放在Word文档或电子表格中, 而这种方式使得这些数据非常难以管理.  选出会影响架构的重要需求——在收集完需求之后, 应该对它们进行审核并选出一个决定架构选择走向的需求子集. 过滤出决定架构的核心需求的过程从某种程度来说是很复杂的, 应该由团队中有相关经验的成员完成. 有时一个很小的需求可能就会要求在架构上做出巨大的变更. 选择出的影响架构的重要需求的确切数目取决于项目, 但范围一般限制在10～20个.  选择NoSQL架构——选出你想纳入候选项的NoSQL架构. 最可能的候选项一般会包括标准关系型数据库, OLAP系统, 键值存储, 列族存储, 图存储和文档存储. 在这个阶段, 不深入具体的产品或实现细节而是了解架构是否契合当前业务问题就显得非常重要了. 多数情况下, 你可以首先剔除一些明显不合适的架构. 例如, 如果需要实现事务性更新, 那么可以直接将OLAP实现方式剔除掉. 如果需要根据键值对中的值部分搜索, 那么你还可以将键值存储剔除出去. 但这并不意味着你不可以在一个混合系统中引入这些架构, 而仅仅是说明它们自身不能解决当前问题.  为关键需求创建用例——用例是阐述用户或机会如何与系统交互的描述性文档. 它们由清楚业务细节的领域专家(subject matter expert)或业务分析师(business analyst)编写. 用例应该足够详尽, 这样才方便工作量的分析. 根据项目大小和需要的细节, 用例可以是简单的句子, 也可以是长达数页的文档. 许多用例都是围绕数据的生命周期构建的. 例如, 你可能会有4个用例: 一个添加新记录用例, 一个展示记录列表用例, 一个搜索数据用例, 还有一个导出数据用例.  估计每个用例在每个架构下所需要的工作量级别——针对每个用例, 需要确定一个粗略的工作量需求级别并制定一个打分标准, 例如, 1表示最难, 5表示最容易. 在确定好工作量后, 需要将为每个用例选择一个合适的数字并填入一个像图12-3一样的电子表格中.  图12-3　将用例分类的项目的架构权衡打分表样例. 简单起见, 所有用例的权重都是相同的 用加权后的打分结果排名候选架构——在这个阶段, 你将结合工作量和某种加权策略为每个架构计算出一个得分. 与项目成功相关的关键性元素和易于实现的元素的得分最高, 而低优先级和不易实现的元素则会得到较低的分数. 通过像图12-4这样将加权后的得分相加的方式, 你将会得到可以用于比较每个架构的综合性得分.  图12-4　一个状态管理系统软件选型的加权打分表. 这个表格描述了4种候选架构上执行某个任务的难易程度. 分数范围是0～4, 其中4代表最少的工作量. 在表格中, 最为关键的功能会在最后结果中占有最高的权重 在第一次加权时, 工作量的估计可能比较粗略. 可以先用一个像高, 中, 低这样的简单级别分类. 随着对结果的估计越来越准确, 就可以选用一个像1～5这样的较细粒度的分类, 其中数字越大则工作量越少. 
每个用例相对其他用例的加权结果也应该能帮助你的团队在每项功能的相对重要性上达成共识. 用例还可以用来理楚项目中存在的风险因素. 在做项目风险管理的时候, 被标记为关键的功能需要项目经理加以特别重视.  文档输出——在架构权衡过程的每个步骤都会产出一系列文档. 这些文档可以综合到一份报表中并被发给利益相关者. 这份报表将会包含一些与你需要和利益相关者沟通交流的话题有关的背景信息. 这些文档可以以各种形式进行共享, 如报表构成的网站, Word文档, 电子表格, 幻灯片, 墙面大小的彩色海报以及我们在本章稍后的部分会提到的质量树.  结果交流——一旦准备好相关文档, 你就可以展示最终结果了. 选用的展示方式的关注点应该集中在体现选型团队决定的可信度. 用电子邮件附件的方式发送一份长达100页的报告不会引起相关人士的兴趣, 但如果通过一种互动的方式展示结果, 就可以用一些听众可以理解的词汇使他们感到事情的紧迫性. 

--------

