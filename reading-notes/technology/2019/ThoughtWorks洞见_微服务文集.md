# ThoughtWorks洞见－微服务文集

[书籍](https://www.amazon.cn/dp/B06XBZGZ7Y)

> (2019/02/03-2019/02/04)

1. Microservices不是一门科学, 而仅仅是实践. 就像是面向对象编程一样. 最终应当是需求, 是人来决定架构而非架构决定需求. 
    * 主要合适就行
2. 像是当年大家为了追求极致的执行效率试图将代码塞进64K的代码段一样, 我们今天奉为经典的东西未来可能只是茶余饭后的谈资. 我们能做的只有保持开放的心态, 坚持辩证的观点, 坚持从实际出发, 寻找出最合适的解决方案. 
    * 历史的局限性
3. 每个服务是不是跑在独立的进程中? 是不是采用轻量级的通讯机制? 是不是可以做到独立的部署? 
4. Martin Fowler在他的《企业应用架构模式》中, 就提到了分布式对象设计的第一原则: "设计分布式对象的第一个原则就是不要使用分布式对象". 因为分布式系统会给我们带来很大的挑战, 让系统复杂度大幅增加的同时, 我们还需要面对开发环境, 测试, 部署, 运维, 监控, 一致性和事务等一系列的问题. 
5. 我们刚才提到了康威定律, 康威定律说的是设计系统的组织产生的设计和架构等价于组织间的沟通结构. 而康威定律还有一个逆定律: 如果想改变一个设计架构方式, 首先要改变组织结构. 
    * 这个开发的始终是一个团队, 团队之间的关系会影响这个系统架构
6. 为了实现这些目标, 企业需要将敏捷性/适应性集成到三个领域: 人, 流程和技术. 
7. 数字时代就在我们身边. 将软件开发视为高成本开销而不是竞争力的企业将会举步维艰. 
8. 标准化一直是IT组织降低成本的方式之一. 不幸的是, 它也降低了灵活性—标准化越多, 灵活性越少. 通过采纳微服务架构, 架构师和开发人员可以使用更加多样化且能够紧密反映问题复杂度的技术栈来设计应用程序. 
9. 1968年, 梅尔文·康威对软件开发做了一个很有预见性的观察, 被称为康威定律:  设计系统的组织, 其产生的设计等价于这些组织间的沟通结构. 
10. 微服务的另外一个特点是, 这些服务是按照业务能力构建的. 之前我们经常掉入一个陷阱, 就是总是从系统的角度思考问题, 而不是从业务角度. 
    * 曾经和某个人讨论过微服务拆分, 我是按照业务和功能拆分. 另一个人忘了, 他的业务能力太强总能反驳我的拆分方式. 之后不了了之了.
11. 在微服务中, 我们主张"智能端点"和"傻瓜管道". 基本上如果管道两边都按照一定的假设强制执行的话, 重新配置时就会简单许多, 而并不需要时刻监控管道中的中间状态. 
    * 中间人不要做太多处理, 顺水传递就好. 只要有逻辑就会出现蛋疼的监控.
13. 因此在微服务架构中, 我们必须要避免引入所有类型的编程语言以及所有种类的数据库, 没什么原因, 明眼人都知道我们不能这么做. 在系统的技术栈方面, 我们必须在某个层面进行控制, 否则一发不可收拾了. 
    * 微服务一大优势就是可以使用不同技术栈, 但是技术栈过多会导致系统庞杂而难以维护
14. 我们发现如果你始终沿着方便测试的方向设计架构, 最后的架构会更加简洁. 而且易于测试的系统一定是有一个清楚的定义的, 你甚至不需要颗粒度太细的测试, 哪怕只有一个非常顶层的端到端测试, 只要这个测试能简单明了的描述其行为就已足够. 当你的架构设计得很好, 边界划分得很清楚, 系统本身就应该是很好测试的. 我们发现, 一般而言, 不管是从代码层面还是系统层面, 关注测试始终会让你的架构更加完善. 而且一般而言, 基于测试定义的边界, 也让整个架构更容易做出改变. 
15. 在一个崭新的项目上, 始终建议从一个单块架构开始, 因为你不可避免地会犯一些边界划分的错误, 除非你真的是对于这个领域烂熟于胸. 
    * 不要上来就为服务, 单框架也可以是微服务的, 只要对外接口和协议不变就可以. 之后拆分就好了.
16. 就像在进化计算技术中的遗传算法一样, 一个架构级别的适应度函数指明了我们的目标架构是什么样子, 其中一些系统关注高运行时间, 而其他一些系统则会更关注吞吐量或者安全. 
17. 受极限编程社区的启发, 许多持续交付和演进式架构的实践都体现了"痛苦的事提前做"原则. 在做一个项目的时候, 如果一些事情可能会很痛苦, 那么你需要强迫自己更早更频繁地去做这些事情. 这反过来会鼓励你用自动化的手段消除这些痛苦并能提前识别问题. 
    * 有限把不好做的提前抽象和自动化. 即使困难也要提前做可以提高效率
18. 那些基础的持续交付实践, 如部署流水线, 自动化基础设施建构, 数据库迁移, 就是这一原则的应用, 它们会提早解决变更带来的常规问题, 从而使架构的演进更容易. 
19. 决策的时机是传统架构和演进式架构的最主要区别. 这些决策可以围绕应用程序的结构, 技术栈, 特定的工具或通信模式. 在传统的架构中, 这些决策发生在早期写代码之前. 而在演进式的架构中, 它们发生在最后责任时刻. 延迟决策的好处是有更多可用的信息来辅助决策. 其成本体现在做出决定后任何可能出现的重复工作中, 这些工作可以通过适当的抽象得到减轻, 但成本仍然是实打实存在的. 相比而言, 决定太早的成本也是很明显的. 比如一个通讯工具的选择, 不同的工具有不同的特性. 如果我们选择一个可能最终也不会用到的重量级工具, 那就是在项目中引入了技术债. 
20. 即使在敏捷开发主流化的今天, 很多团队仍然是架构师"画图", 码农堆砌代码. 所以这样的组织很快发现自己深陷二进制的泥潭, 进退维谷. 我经常跟这样的团队讲: 你们缺乏"代码的响应力". 而响应力对组织的要求就是灵活, 能够从前到后驾驭设计活动带来的不确定性. 
    * 最讨厌ppt架构师, 不要只顾着吹牛, 程序员是需要导师的.
21. 在面对市场情况高度不确定性时, 我们应该直面试错这件事情. 传统职能型的大组织结构往往是不能容错的, 错误的代价就是整个企业走偏了方向, 或者一个部门在企业里失去了话语权.  在灵活性高的组织里我们却应该是能够很容易进行这样的"测试", 企业更能够利用这样的结构进行动态的投资组合管理, 像Google著名的7:2:1投资比例, 最后的一成就是利用组织的灵活性进行创新的测试. 测试的结果往往是失败的, 但正是这样的不断测试创造了Google历史上很多著名的"黑天鹅". 
    * 快速的试错是走向成功的最重要方式. 不然就要每一步都要走对, 那就太难了.
23. 尽早识别剥离通用领域. 如身份认证与鉴权领域, 是企业系统中最复杂, 有相对多变的领域, 需要及早隔离它对核心业务的干扰. 
    * 中间件就是一种特殊的微服务
24. "旧的不变, 新的创建, 一步切换, 旧的再见". 
    * 简单的切换方案. 我很喜欢
25. 什么是微服务?
    1. 小，且专注于做一件事情
    2. 运行在独立的进程中
    3. 轻量级的通信机制
    4. 松耦合
26. 微服务的优势? 
    1. 独立测试与部署
    2. 按需伸缩
    3. **错误隔离性**
    4. 团队全功能化

--------

* 康威定律这本书一定要找时间读一读.
* 书中功能说了很多, 有一些收获. 微服务的拆分更多应该有有业务需求去开始. 慢慢抽丝剥茧去拆分
* 快速试错, 按照这个逻辑会存在什么框架或代码结构呢? 可以思考看看
* 没有银弹.